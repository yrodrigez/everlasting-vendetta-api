# Authentication Migration Plan
## Enterprise-Grade JWT Token System with Refresh Token Rotation

**Goal**: Migrate from cookie-based authentication to a modern JWT token system with access tokens in memory, refresh tokens in HTTP-only cookies, automatic rotation, and breach detection.

**Learning Focus**: Token security, JWT internals, rotation strategies, breach detection, and Supabase Edge Functions.

---

## ğŸ“‹ Table of Contents
1. [Current State](#current-state)
2. [Target Architecture](#target-architecture)
3. [Security Features](#security-features)
4. [Database Schema](#database-schema)
5. [Implementation Phases](#implementation-phases)
6. [API Endpoints](#api-endpoints)
7. [Client-Side Implementation](#client-side-implementation)
8. [Migration Strategy](#migration-strategy)
9. [Testing Plan](#testing-plan)
10. [Rollback Plan](#rollback-plan)

---

## ğŸ” Current State

### Authentication Flow (Cookie-Based)

**Your existing implementation**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              1. OAuth Login (Battle.net/Discord)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User clicks "Login with Battle.net"
  â†“
/api/v1/oauth/bnet/auth â†’ Redirect to Battle.net OAuth
  â†“
User authorizes on Battle.net
  â†“
/api/v1/oauth/bnet/callback (receives authorization code)
  â†“
Exchange code for Battle.net access token
  â†“
Store in cookie: bnetToken (expires ~1 hour, accessible to JS)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          2. Session Installation (Character Selection)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User selects character (frontend)
  â†“
SessionManager.initializeSession() checks:
  - Has evToken cookie? â†’ Validate it's for selected character
  - No evToken but has bnetToken? â†’ Call /api/v1/supabase/auth
  â†“
POST /api/v1/supabase/auth
  Body: {bnetToken, selectedCharacter}
  â†“
Backend calls Supabase Edge Function: ev_token_generate
  1. Validate bnetToken with Battle.net API
  2. Fetch user's WoW profile/characters
  3. Create/update user in Supabase (public.users, ev_member)
  4. Generate custom JWT token (evToken, 23 hours expiry)
  â†“
Return evToken â†’ Store in cookie (accessible to JS)
  â†“
Frontend creates Supabase client with evToken
  â†“
User can make authenticated API calls


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         3. Automatic Token Refresh (Current Behavior)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

On page load/character change:
  â†“
Check if evToken exists and matches selected character
  â”œâ”€ YES: Use existing evToken (no API call)
  â”œâ”€ NO evToken but has bnetToken:
  â”‚    â†’ Regenerate evToken (call /api/v1/supabase/auth)
  â””â”€ NO bnetToken:
       â†’ Redirect to /api/v1/oauth/bnet/auth (re-login)
```

**Current Tokens**:
- **bnetToken** (cookie, ~1 hour): Battle.net OAuth access token, accessible to JS
- **discordToken** (cookie, ~7 days): Discord OAuth access token, accessible to JS
- **evToken** (cookie, 23 hours): Your app's custom JWT, generated by Supabase Edge Function `ev_token_generate`

**Current Files**:
- `/api/v1/oauth/bnet/callback/route.ts` - OAuth callback, stores bnetToken
- `/api/v1/supabase/auth/route.ts` - Session installer, generates evToken
- `SessionManager.ts` - Frontend session management, auto-refresh logic
- Supabase Edge Function: `ev_token_generate` - Token generation logic

### Issues with Current Approach
- âŒ **All tokens in cookies, accessible to JS** (`sameSite: 'lax'`, not `httpOnly`) â†’ XSS vulnerable
- âŒ **No refresh token** - When bnetToken expires (~1 hour), user must re-login via OAuth
- âŒ **Character-specific tokens** - Switching characters regenerates evToken (unnecessary)
- âŒ **No session revocation** - Can't logout from other devices
- âŒ **No device tracking** - Can't see where you're logged in
- âŒ **No breach detection** - Stolen evToken is valid for 23 hours
- âŒ **OAuth tokens mixed with app tokens** - bnetToken stored alongside evToken (confusing)
- âŒ **23-hour session limit** - evToken expires, then needs bnetToken (which might also be expired)

---

## ğŸ¯ Key Architecture Decisions

### Decision 1: User-Based Auth vs Character-Based Auth

**Problem**: Current system ties tokens to selected character. Switching characters = new token.

**Options Considered**:
- **Option A**: Keep character in access token payload (requires refresh on character switch)
- **Option B**: Decouple character from auth (character = UI state only)

**Decision**: **Option B - Decouple character from authentication** âœ…

**Rationale**:
- Clean separation of concerns (auth = user identity, character = application state)
- No re-authentication when switching characters
- Standard pattern used by major WoW sites (WoWAudit, RaidHelper)
- Better UX (instant character switching)

**Implementation**:
```typescript
// Access token = User identity only
{
  sub: "user-uuid",
  email: "user@example.com",
  bnet_id: "123456",
  roles: ["member", "raider"]
  // NO character data in token
}

// Character selection = Client-side state (Zustand/Context)
const { selectedCharacter, setSelectedCharacter } = useCharacterStore();

// API queries pass both user_id and character_id
supabase
  .from('reservations')
  .select('*')
  .eq('user_id', user.id)
  .eq('character_id', selectedCharacter.id);
```

---

### Decision 2: Token Passing Method (OAuth Callback â†’ Client)

**Problem**: How to securely pass access token from OAuth callback to client?

**Options Considered**:
- **Option A**: URL hash fragment (`/dashboard#access_token=...`)
- **Option B**: Authorization Code Flow with PKCE (refresh endpoint)
- **Option C**: Session cookie (HTTP-only, server-side only)

**Decision**: **Option B - OAuth 2.0 Authorization Code Flow** âœ…

**Rationale**:
- **Most secure**: No tokens in URL (not in history, logs, or referrer headers)
- **Industry standard**: Used by Auth0, Supabase Auth, Clerk, NextAuth
- **XSS protection**: Refresh token in HTTP-only cookie, access token in memory
- **Works with Supabase direct access**: Client needs access token for Supabase client

**Flow**:
```
1. OAuth callback
   - Generate tokens via Supabase Edge Function
   - Store ONLY refreshToken in HTTP-only cookie
   - Redirect WITHOUT tokens in URL (clean redirect)

2. Client mounts (AuthContext)
   - Automatically calls /api/v1/auth/refresh
   - Receives accessToken in response
   - Stores in memory (useState)

3. User is authenticated
   - Access token auto-refreshes every 14 minutes (before expiry)
   - Refresh token rotates on each refresh
```

---

### Decision 3: Client-Side Architecture (Supabase Direct vs API Routes)

**Problem**: Need both Supabase direct access AND Next.js API routes.

**Solution**: **Hybrid Approach** âœ…

**Implementation**:
```typescript
// AuthContext provides BOTH
const { supabase, accessToken } = useAuth();

// 1. Supabase Direct Access (preferred for DB queries)
const roster = await supabase
  .from('ev_member')
  .select('*');
// âœ… Fast (no API hop), works with RLS, realtime subscriptions

// 2. Axios for Next.js API Routes (optional)
import api from '@/app/lib/axios';
const data = await api.get('/services/roster');
// âœ… For complex server-side logic, external API proxies
```

**Rationale**:
- Keep existing Supabase direct access pattern (already used in components)
- Axios optional for API routes that need server-side processing
- No forced migration to API routes (gradual adoption)

---

### Decision 4: Token Storage Strategy

**Problem**: Where to store access tokens and refresh tokens?

**Decision**: **Industry Standard OAuth 2.0 Pattern** âœ…

**Implementation**:
```
Access Token:
  - Storage: React state (memory only)
  - Lifetime: 15 minutes
  - Auto-refresh: 1 minute before expiry
  - Lost on page reload: YES (re-fetch via refresh endpoint)
  - XSS Protection: âœ… Not in localStorage or cookies

Refresh Token:
  - Storage: HTTP-only cookie
  - Lifetime: 30 days
  - Rotation: New token on every refresh
  - JavaScript Access: âŒ Cannot be read by JS
  - CSRF Protection: âœ… SameSite=strict

Battle.net OAuth Token (bnetToken):
  - Storage: ev_auth.oauth_providers table (database)
  - Returned: In /auth/refresh response if needed
  - Usage: Battle.net API calls only
  - Client Access: Available via useAuth() hook
```

---

### Decision 5: Error Handling Pattern

**Problem**: TypeScript doesn't enforce try/catch (no checked exceptions).

**Solution**: **Result Type Pattern** âœ…

**Implementation**:
```typescript
// Result type for type-safe error handling
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

type AuthError =
  | { type: 'network'; message: string }
  | { type: 'unauthorized'; message: string }
  | { type: 'expired'; message: string };

// Functions return Result instead of throwing
const refreshToken = async (): Promise<Result<string, AuthError>> => {
  // ...
  if (!res.ok) {
    return { success: false, error: { type: 'unauthorized', message: 'Refresh failed' } };
  }
  return { success: true, data: accessToken };
};

// TypeScript forces error handling
const result = await refreshToken();
if (result.success) {
  console.log(result.data);  // TypeScript knows this is string
} else {
  console.error(result.error.type, result.error.message);
}
```

**Rationale**:
- Compiler-enforced error handling
- Better than neverthrow (no external dependency)
- Self-documenting error types

---

### Decision 6: Character Selection Flow

**Current Flow** (Character-First):
```
1. OAuth â†’ bnetToken cookie
2. User selects character
3. Call ev_token_generate(bnetToken, character)
4. Get character-specific token
```

**New Flow** (User-First): âœ…
```
1. OAuth â†’ User-based JWT tokens (no character data)
2. Fetch all user's characters from Battle.net API
3. Store characters in database (ev_member)
4. Client-side character selection (no re-auth)
5. Selected character stored in Zustand/localStorage
6. API queries use: user.id + selectedCharacter.id
```

**Benefits**:
- Instant character switching (no API call)
- One authentication per user (not per character)
- Standard MMO site pattern

---

## ğŸ—ï¸ Target Architecture

### New Authentication Flow
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      1. OAuth Login Flow                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User clicks "Login with Battle.net/Discord"
  â†“
Redirect to OAuth provider
  â†“
User authorizes
  â†“
OAuth callback receives authorization code
  â†“
Exchange code for provider tokens (in Supabase Edge Function)
  â†“
Create/Update user in Supabase auth.users
  â†“
Generate Token Pair:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Access Token (JWT)                                          â”‚
  â”‚ - Expires: 15 minutes                                       â”‚
  â”‚ - Stored: Client memory (React Context)                    â”‚
  â”‚ - Contains: user_id, roles, email, guild_rank, provider    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Refresh Token (JWT)                                         â”‚
  â”‚ - Expires: 30 days                                          â”‚
  â”‚ - Stored: HTTP-only, Secure, SameSite cookie               â”‚
  â”‚ - Contains: user_id, jti (token ID), family_id, provider   â”‚
  â”‚ - Saved in database for revocation tracking                â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
Response:
  {
    "accessToken": "eyJhbG...",
    "expiresIn": 900,
    "tokenType": "Bearer"
  }
  + Set-Cookie: refreshToken=...; HttpOnly; Secure; SameSite=Strict


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   2. API Request Flow                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Client makes API request
  â†“
Attach access token: Authorization: Bearer <accessToken>
  â†“
API validates JWT signature + expiry
  â†“
Extract user info from token payload
  â†“
Process request


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  3. Token Refresh Flow                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

API returns 401 (access token expired)
  â†“
Client interceptor catches 401
  â†“
Call /api/v1/auth/refresh (refresh token sent via cookie)
  â†“
Supabase Edge Function validates refresh token:
  1. Verify JWT signature
  2. Check expiry
  3. Lookup token_jti in database
  4. Ensure not revoked
  5. Check token family is valid
  â†“
Token Rotation (Security Feature):
  - Generate NEW access token
  - Generate NEW refresh token (same family)
  - Invalidate OLD refresh token in database
  - Update last_used_at timestamp
  â†“
Return new access token + set new refresh token cookie
  â†“
Client retries original request with new access token


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              4. Breach Detection (Token Reuse)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Attacker steals old refresh token
  â†“
Attacker attempts to use already-rotated token
  â†“
System detects reuse (token exists but is already used/rotated)
  â†“
SECURITY BREACH DETECTED!
  â†“
Revoke ENTIRE token family (all tokens from that login session)
  â†“
Force user to re-login
  â†“
Log security event for audit
```

---

## ğŸ”’ Security Features

### 1. Token Rotation
- **What**: Generate new refresh token on every refresh request
- **Why**: Limits exposure window if token is stolen
- **How**: Each refresh invalidates old token and issues new one

### 2. Token Families
- **What**: Group of tokens from same login session
- **Why**: Detect when stolen token is used after rotation
- **How**: All tokens share family_id; reuse detection revokes entire family

### 3. Sliding Window Sessions
- **What**: Users stay logged in as long as they're active
- **Why**: Better UX without compromising security
- **How**: Each refresh extends session by 30 days

### 4. Rate Limiting
- **Endpoints**:
  - `/auth/refresh`: 10 requests/minute per IP
  - `/oauth/*/callback`: 5 requests/minute per IP
  - `/auth/revoke`: 20 requests/minute per user
- **Implementation**: Upstash Redis or Supabase rate limiting

### 5. Device Tracking
- **What**: Track IP, user agent, last used time per token
- **Why**: Users can see and revoke suspicious sessions
- **How**: Store device info in refresh_tokens table

### 6. Concurrent Session Limits
- **What**: Max 5 active sessions per user
- **Why**: Prevent account sharing / credential stuffing
- **How**: Auto-revoke oldest session when limit exceeded

### 7. Audit Logging
- **Events to Log**:
  - Login (success/failure)
  - Token refresh
  - Token revocation
  - Breach detection
  - Password changes (if implemented)
- **Storage**: Supabase audit_logs table

---

## ğŸ—„ï¸ Database Schema

### Current State Analysis

Your existing database has:
- **`public.users`** - Basic user info (id, name, avatar_url, user_name)
- **`public.ev_member`** - Guild member data linked to users (user_id â†’ users.id, character JSON, wow_account_id)
- **Custom schema: `ev_auth`** - Your custom authentication schema (NEW)

### New Auth Architecture

We'll use your custom `ev_auth` schema for all authentication tables. The relationship will be:

```
public.users (your existing app data)
    â†“ (id)
ev_auth.oauth_providers (NEW - track Battle.net & Discord OAuth)
    â†“
ev_auth.refresh_tokens (NEW - JWT token management)
    â†“
ev_auth.token_families (NEW - breach detection)
    â†“
ev_auth.auth_audit_logs (NEW - security monitoring)
```

### Supabase Tables (PostgreSQL)

#### 0. Schema Creation
```sql
-- Create custom auth schema
CREATE SCHEMA IF NOT EXISTS ev_auth;

-- Grant permissions
GRANT USAGE ON SCHEMA ev_auth TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA ev_auth TO postgres, service_role;
GRANT SELECT ON ALL TABLES IN SCHEMA ev_auth TO anon, authenticated;
```

#### 1. public.users (Existing - Enhanced)

**Your current table** (enhanced with auth fields):
```sql
-- Existing table structure (keep as is)
CREATE TABLE IF NOT EXISTS public.users (
  id TEXT PRIMARY KEY,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_modified TIMESTAMPTZ,
  name TEXT,
  user_name TEXT
);

-- Add these columns for enhanced auth (safe - won't affect existing data)
ALTER TABLE public.users
  ADD COLUMN IF NOT EXISTS email TEXT,
  ADD COLUMN IF NOT EXISTS is_banned BOOLEAN DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS banned_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS banned_reason TEXT,
  ADD COLUMN IF NOT EXISTS last_login_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS last_login_ip INET;

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);
CREATE INDEX IF NOT EXISTS idx_users_banned ON public.users(is_banned) WHERE is_banned = TRUE;

-- RLS (if not already enabled)
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

CREATE POLICY IF NOT EXISTS "Users can read all users" ON public.users
  FOR SELECT USING (true);

CREATE POLICY IF NOT EXISTS "Users can update own profile" ON public.users
  FOR UPDATE USING (id = current_setting('request.jwt.claims', true)::json->>'sub');
```

**Note**: Your `ev_member` table already tracks guild-specific data. The `users` table remains the source of truth for user identity across both Battle.net and Discord logins.

#### 2. ev_auth.oauth_providers (NEW - Multi-Provider Tracking)

This table tracks which OAuth providers (Battle.net, Discord) a user has connected:

```sql
CREATE TABLE ev_auth.oauth_providers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- User relationship
  user_id TEXT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  provider TEXT NOT NULL CHECK (provider IN ('bnet', 'discord')),

  -- Provider-specific IDs
  provider_user_id TEXT NOT NULL,  -- Battle.net ID or Discord snowflake
  provider_username TEXT,           -- BattleTag (e.g., "Player#1234") or Discord username
  provider_email TEXT,              -- Email from OAuth provider

  -- OAuth tokens (encrypted, for API calls to provider)
  -- These are the Battle.net/Discord tokens, NOT our JWT tokens
  access_token TEXT,               -- Provider's access token
  refresh_token TEXT,              -- Provider's refresh token (if available)
  token_expires_at TIMESTAMPTZ,

  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ,
  last_sync_at TIMESTAMPTZ,        -- Last time we synced data from provider

  -- Provider-specific data (JSON)
  metadata JSONB,                  -- Store WoW account IDs, Battle.net profile, Discord guilds, etc.

  -- Constraints: User can link each provider once
  UNIQUE(provider, provider_user_id),  -- One Battle.net/Discord account globally
  UNIQUE(user_id, provider)            -- User can link each provider once
);

CREATE INDEX idx_oauth_providers_user ON ev_auth.oauth_providers(user_id);
CREATE INDEX idx_oauth_providers_provider ON ev_auth.oauth_providers(provider, provider_user_id);

-- RLS
ALTER TABLE ev_auth.oauth_providers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own providers" ON ev_auth.oauth_providers
  FOR SELECT USING (user_id = current_setting('request.jwt.claims', true)::json->>'sub');

CREATE POLICY "Service role full access" ON ev_auth.oauth_providers
  FOR ALL USING (auth.role() = 'service_role');
```

**Example Data**:
```sql
-- User "John" has both Battle.net and Discord linked
INSERT INTO ev_auth.oauth_providers VALUES
  ('uuid1', 'user123', 'bnet', '987654321', 'John#1234', 'john@bnet.com', 'bnet_token', NULL, NOW() + INTERVAL '1 hour', NOW(), NULL, NULL, '{"wow_accounts": [123, 456]}'),
  ('uuid2', 'user123', 'discord', '123456789', 'John#5678', 'john@discord.com', 'discord_token', NULL, NOW() + INTERVAL '7 days', NOW(), NULL, NULL, '{"guilds": ["789"]}');
```

#### 3. ev_auth.refresh_tokens (NEW - JWT Session Management)

```sql
CREATE TABLE ev_auth.refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- User and authentication
  user_id TEXT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  token_jti TEXT UNIQUE NOT NULL,  -- JWT ID (unique identifier)
  family_id UUID NOT NULL REFERENCES ev_auth.token_families(id) ON DELETE CASCADE,
  provider TEXT NOT NULL CHECK (provider IN ('bnet', 'discord')),

  -- Token lifecycle
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  last_used_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_reason TEXT,  -- 'manual', 'breach_detected', 'session_limit', 'logout_all'

  -- Device tracking
  ip_address INET,
  user_agent TEXT,
  device_fingerprint TEXT,  -- Optional: client-generated device ID

  -- Metadata
  is_rotated BOOLEAN DEFAULT FALSE,  -- Track if token was rotated
  rotated_to_jti TEXT  -- Points to new token after rotation
);

-- Indexes for performance
CREATE INDEX idx_refresh_tokens_user_id ON ev_auth.refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_jti ON ev_auth.refresh_tokens(token_jti);
CREATE INDEX idx_refresh_tokens_family ON ev_auth.refresh_tokens(family_id);
CREATE INDEX idx_refresh_tokens_expires ON ev_auth.refresh_tokens(expires_at) WHERE revoked_at IS NULL;

-- RLS Policies
ALTER TABLE ev_auth.refresh_tokens ENABLE ROW LEVEL SECURITY;

-- Users can only read their own tokens (for device management)
CREATE POLICY "Users can read own tokens" ON ev_auth.refresh_tokens
  FOR SELECT USING (user_id = current_setting('request.jwt.claims', true)::json->>'sub');

-- Service role can manage all tokens
CREATE POLICY "Service role full access" ON ev_auth.refresh_tokens
  FOR ALL USING (auth.role() = 'service_role');
```

#### 4. ev_auth.token_families (NEW - Breach Detection)

```sql
CREATE TABLE ev_auth.token_families (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  provider TEXT NOT NULL CHECK (provider IN ('bnet', 'discord')),

  -- Lifecycle
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_used_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_reason TEXT,

  -- Security
  breach_detected_at TIMESTAMPTZ,  -- When reuse was detected
  original_ip_address INET,         -- IP of initial login

  -- Metadata
  device_count INTEGER DEFAULT 1    -- Track how many rotations occurred
);

CREATE INDEX idx_token_families_user ON ev_auth.token_families(user_id);
CREATE INDEX idx_token_families_active ON ev_auth.token_families(user_id, revoked_at) WHERE revoked_at IS NULL;

-- RLS
ALTER TABLE ev_auth.token_families ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own families" ON ev_auth.token_families
  FOR SELECT USING (user_id = current_setting('request.jwt.claims', true)::json->>'sub');

CREATE POLICY "Service role full access" ON ev_auth.token_families
  FOR ALL USING (auth.role() = 'service_role');
```

#### 5. ev_auth.auth_audit_logs (NEW - Security Monitoring)

```sql
CREATE TABLE ev_auth.auth_audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Event details
  event_type TEXT NOT NULL,  -- 'login', 'refresh', 'revoke', 'breach_detected', 'logout'
  user_id TEXT REFERENCES public.users(id) ON DELETE SET NULL,
  provider TEXT CHECK (provider IN ('bnet', 'discord')),

  -- Context
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ip_address INET,
  user_agent TEXT,

  -- Additional metadata
  metadata JSONB,  -- Flexible storage for event-specific data
  success BOOLEAN NOT NULL,
  error_message TEXT
);

CREATE INDEX idx_audit_logs_user ON ev_auth.auth_audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_event ON ev_auth.auth_audit_logs(event_type, created_at DESC);
CREATE INDEX idx_audit_logs_created ON ev_auth.auth_audit_logs(created_at DESC);

-- RLS
ALTER TABLE ev_auth.auth_audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own logs" ON ev_auth.auth_audit_logs
  FOR SELECT USING (user_id = current_setting('request.jwt.claims', true)::json->>'sub');

CREATE POLICY "Service role full access" ON ev_auth.auth_audit_logs
  FOR ALL USING (auth.role() = 'service_role');
```

---

### Database Schema Summary

```
ev_auth (custom schema)
â”œâ”€â”€ oauth_providers        - Track Battle.net & Discord OAuth connections
â”œâ”€â”€ refresh_tokens         - JWT refresh tokens with rotation
â”œâ”€â”€ token_families         - Group tokens for breach detection
â””â”€â”€ auth_audit_logs        - Security event logging

public (existing schema)
â”œâ”€â”€ users                  - User identity (enhanced with auth fields)
â””â”€â”€ ev_member             - Guild member data (unchanged)
```

**Key Relationships**:
```sql
-- User can have multiple OAuth providers
public.users (1) â”€â”€< (N) ev_auth.oauth_providers

-- User can have multiple active sessions
public.users (1) â”€â”€< (N) ev_auth.refresh_tokens

-- Each login session creates a token family
public.users (1) â”€â”€< (N) ev_auth.token_families

-- Token family contains multiple rotated tokens
ev_auth.token_families (1) â”€â”€< (N) ev_auth.refresh_tokens
```

---

#### 6. Database Functions

**Cleanup Expired Tokens** (Run daily via pg_cron)
```sql
CREATE OR REPLACE FUNCTION ev_auth.cleanup_expired_tokens()
RETURNS void AS $$
BEGIN
  -- Delete expired tokens older than 7 days (keep for audit)
  DELETE FROM ev_auth.refresh_tokens
  WHERE expires_at < NOW() - INTERVAL '7 days';

  -- Delete orphaned token families
  DELETE FROM ev_auth.token_families
  WHERE id NOT IN (SELECT DISTINCT family_id FROM ev_auth.refresh_tokens)
    AND created_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**Revoke Token Family**
```sql
CREATE OR REPLACE FUNCTION ev_auth.revoke_token_family(
  p_family_id UUID,
  p_reason TEXT DEFAULT 'manual'
)
RETURNS void AS $$
BEGIN
  -- Revoke all tokens in family
  UPDATE ev_auth.refresh_tokens
  SET revoked_at = NOW(), revoked_reason = p_reason
  WHERE family_id = p_family_id AND revoked_at IS NULL;

  -- Mark family as revoked
  UPDATE ev_auth.token_families
  SET revoked_at = NOW(), revoked_reason = p_reason
  WHERE id = p_family_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**Enforce Session Limits**
```sql
CREATE OR REPLACE FUNCTION ev_auth.enforce_session_limit(
  p_user_id TEXT,
  p_max_sessions INTEGER DEFAULT 5
)
RETURNS void AS $$
BEGIN
  -- Revoke oldest sessions beyond limit
  WITH ranked_sessions AS (
    SELECT id,
           ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY last_used_at DESC NULLS LAST, created_at DESC) as rn
    FROM ev_auth.refresh_tokens
    WHERE user_id = p_user_id
      AND revoked_at IS NULL
      AND expires_at > NOW()
  )
  UPDATE ev_auth.refresh_tokens
  SET revoked_at = NOW(), revoked_reason = 'session_limit'
  WHERE id IN (
    SELECT id FROM ranked_sessions WHERE rn > p_max_sessions
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

## ğŸ“¦ Implementation Phases

### Phase 1: Database & Infrastructure Setup â±ï¸ 2-3 hours
- [ ] Create database migration files
- [ ] Run migrations on Supabase
- [ ] Set up pg_cron for token cleanup
- [ ] Create Supabase Edge Function project structure
- [ ] Configure environment variables (JWT secrets)

### Phase 2: JWT Utilities & Token Service â±ï¸ 3-4 hours
- [ ] Create JWT utility module (sign, verify, decode)
- [ ] Create token service layer:
  - `issueTokenPair(userId, provider, deviceInfo)` â†’ { accessToken, refreshToken }
  - `verifyAccessToken(token)` â†’ decoded payload
  - `verifyRefreshToken(token)` â†’ validated token data
  - `rotateRefreshToken(oldJti, userId, familyId)` â†’ new token pair
  - `revokeToken(jti, reason)` â†’ void
  - `revokeAllUserTokens(userId, reason)` â†’ void
  - `detectTokenReuse(jti)` â†’ boolean (breach detection)

### Phase 3: Supabase Edge Functions â±ï¸ 4-5 hours
- [ ] **auth-refresh** function
  - Read refresh token from cookie
  - Validate + detect reuse
  - Rotate token
  - Return new access token
- [ ] **auth-revoke** function (logout single session)
- [ ] **auth-revoke-all** function (logout all devices)
- [ ] **auth-sessions** function (list active sessions)
- [ ] Deploy all Edge Functions

### Phase 4: OAuth Callback Updates â±ï¸ 2-3 hours
- [ ] Update [/api/v1/oauth/bnet/callback/route.ts](src/app/api/v1/oauth/bnet/callback/route.ts)
  - Exchange code for Battle.net tokens
  - Create/update user in Supabase
  - Issue access + refresh token pair
  - Set refresh token in HTTP-only cookie
  - Return access token in response
- [ ] Update [/api/v1/oauth/discord/callback/route.ts](src/app/api/v1/oauth/discord/callback/route.ts)
  - Same flow as Battle.net

### Phase 5: Middleware Updates â±ï¸ 1-2 hours
- [ ] Update [src/middleware.ts](src/middleware.ts)
  - Remove old cookie-based auth
  - Validate refresh token from cookie (for middleware-protected routes)
  - Check if token exists and not expired (lightweight check)
  - Let API routes handle full access token validation

### Phase 6: Client-Side Implementation â±ï¸ 4-5 hours
- [ ] Create AuthContext provider
  - Store access token in memory
  - Provide login/logout/refresh functions
  - Auto-refresh before expiry (background timer)
- [ ] Create axios/fetch interceptor
  - Attach access token to requests
  - Handle 401 responses (call refresh endpoint)
  - Retry failed request with new token
  - Handle refresh failure (logout)
- [ ] Update [src/app/components/LoginButton.tsx](src/app/components/LoginButton.tsx)
  - Integrate with new OAuth flow
  - Store access token after callback
- [ ] Create SessionManager component (show active devices)

### Phase 7: Rate Limiting â±ï¸ 2-3 hours
- [ ] Set up rate limiting (Upstash Redis or in-memory)
- [ ] Apply to auth endpoints
- [ ] Add rate limit headers to responses

### Phase 8: Testing & Validation â±ï¸ 3-4 hours
- [ ] Unit tests for JWT utilities
- [ ] Integration tests for token flow
- [ ] Security tests (token reuse, breach detection)
- [ ] Load testing (concurrent sessions)
- [ ] Manual testing (device management, logout)

### Phase 9: Migration & Deployment â±ï¸ 2-3 hours
- [ ] Deploy to staging environment
- [ ] Run parallel (old + new auth)
- [ ] Migrate existing users
- [ ] Monitor error rates
- [ ] Deploy to production
- [ ] Remove old auth code

**Total Estimated Time**: 23-32 hours

---

## ğŸ”Œ API Endpoints

### Supabase Edge Functions (Located in `supabase/functions/`)

#### 1. POST /api/v1/auth/refresh
**Purpose**: Exchange refresh token for new access token with rotation

**Request**:
```http
POST /api/v1/auth/refresh
Cookie: refreshToken=eyJhbG...
```

**Response** (Success):
```json
{
  "accessToken": "eyJhbG...",
  "expiresIn": 900,
  "tokenType": "Bearer"
}
```
Sets new `refreshToken` cookie

**Response** (Breach Detected):
```json
{
  "error": "token_reuse_detected",
  "message": "Security breach detected. All sessions have been revoked."
}
```
Status: 403

**Logic**:
```typescript
1. Read refresh token from cookie
2. Verify JWT signature
3. Query database for token_jti
4. Check if already rotated (is_rotated = true)
   â†’ If YES: BREACH DETECTED
     - Revoke entire token family
     - Log security event
     - Return 403
5. Validate token not expired/revoked
6. Create new token pair (same family_id)
7. Mark old token as rotated (is_rotated = true, rotated_to_jti = new_jti)
8. Enforce session limits
9. Update last_used_at
10. Log audit event
11. Return new access token + set new refresh token cookie
```

#### 2. POST /api/v1/auth/revoke
**Purpose**: Revoke current session (logout from this device)

**Request**:
```http
POST /api/v1/auth/revoke
Cookie: refreshToken=eyJhbG...
Authorization: Bearer eyJhbG...
```

**Response**:
```json
{
  "success": true,
  "message": "Session revoked successfully"
}
```

**Logic**:
```typescript
1. Read refresh token from cookie
2. Decode to get jti
3. Revoke token in database (set revoked_at, revoked_reason='manual')
4. Clear refresh token cookie
5. Log audit event
```

#### 3. POST /api/v1/auth/revoke-all
**Purpose**: Revoke all user sessions (logout from all devices)

**Request**:
```http
POST /api/v1/auth/revoke-all
Authorization: Bearer eyJhbG...
```

**Response**:
```json
{
  "success": true,
  "message": "All sessions revoked successfully",
  "revokedCount": 5
}
```

**Logic**:
```typescript
1. Verify access token to get user_id
2. Revoke all token families for user
3. Log audit event
```

#### 4. GET /api/v1/auth/sessions
**Purpose**: List all active sessions for user

**Request**:
```http
GET /api/v1/auth/sessions
Authorization: Bearer eyJhbG...
```

**Response**:
```json
{
  "sessions": [
    {
      "id": "uuid",
      "provider": "bnet",
      "createdAt": "2025-10-01T12:00:00Z",
      "lastUsedAt": "2025-10-03T08:30:00Z",
      "expiresAt": "2025-10-31T12:00:00Z",
      "ipAddress": "192.168.1.1",
      "userAgent": "Mozilla/5.0...",
      "isCurrent": true
    }
  ]
}
```

**Logic**:
```typescript
1. Verify access token to get user_id
2. Query active refresh_tokens for user (not revoked, not expired)
3. Group by family_id (show one per login session)
4. Mark current session (compare jti)
5. Return session list
```

---

## ğŸ’» Client-Side Implementation

### 1. AuthContext Provider (`src/app/context/AuthContext.tsx`)

```typescript
interface AuthContextType {
  accessToken: string | null;
  isAuthenticated: boolean;
  user: User | null;
  login: (provider: 'bnet' | 'discord') => void;
  logout: () => Promise<void>;
  logoutAll: () => Promise<void>;
  refreshToken: () => Promise<string>;
  getSessions: () => Promise<Session[]>;
  revokeSession: (sessionId: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }) {
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const refreshTimerRef = useRef<NodeJS.Timeout>();

  // Auto-refresh token before expiry
  useEffect(() => {
    if (!accessToken) return;

    const decoded = jwtDecode(accessToken);
    const expiresIn = decoded.exp * 1000 - Date.now();
    const refreshAt = expiresIn - 60000; // Refresh 1 min before expiry

    refreshTimerRef.current = setTimeout(() => {
      refreshToken();
    }, refreshAt);

    return () => clearTimeout(refreshTimerRef.current);
  }, [accessToken]);

  // Refresh on mount (page reload)
  useEffect(() => {
    refreshToken().catch(() => {
      // Refresh token expired or invalid
      setAccessToken(null);
      setUser(null);
    });
  }, []);

  const refreshToken = async () => {
    const res = await fetch('/api/v1/auth/refresh', {
      method: 'POST',
      credentials: 'include' // Send cookies
    });

    if (!res.ok) {
      throw new Error('Refresh failed');
    }

    const { accessToken } = await res.json();
    setAccessToken(accessToken);

    const decoded = jwtDecode(accessToken);
    setUser({
      id: decoded.sub,
      email: decoded.email,
      roles: decoded.roles,
      provider: decoded.provider
    });

    return accessToken;
  };

  const logout = async () => {
    await fetch('/api/v1/auth/revoke', {
      method: 'POST',
      credentials: 'include'
    });
    setAccessToken(null);
    setUser(null);
  };

  // ... other methods

  return (
    <AuthContext.Provider value={{
      accessToken,
      isAuthenticated: !!accessToken,
      user,
      login,
      logout,
      logoutAll,
      refreshToken,
      getSessions,
      revokeSession
    }}>
      {children}
    </AuthContext.Provider>
  );
}
```

### 2. Axios Interceptor (`src/app/lib/axios.ts`)

```typescript
import axios from 'axios';
import { useAuth } from '@/app/context/AuthContext';

const api = axios.create({
  baseURL: '/api/v1',
  withCredentials: true
});

// Request interceptor: attach access token
api.interceptors.request.use((config) => {
  const { accessToken } = useAuth();

  if (accessToken) {
    config.headers.Authorization = `Bearer ${accessToken}`;
  }

  return config;
});

// Response interceptor: handle 401 (expired token)
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // If 401 and not already retried
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const { refreshToken } = useAuth();
        const newAccessToken = await refreshToken();

        // Retry original request with new token
        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
        return api(originalRequest);
      } catch (refreshError) {
        // Refresh failed, redirect to login
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default api;
```

### 3. OAuth Callback Handler (Client-Side)

```typescript
// src/app/oauth-callback/page.tsx
'use client';

import { useEffect } from 'react';
import { useAuth } from '@/app/context/AuthContext';
import { useRouter } from 'next/navigation';

export default function OAuthCallbackPage() {
  const { refreshToken } = useAuth();
  const router = useRouter();

  useEffect(() => {
    async function handleCallback() {
      try {
        // Server-side callback already set refresh token cookie
        // Now just fetch the access token
        await refreshToken();

        // Redirect to dashboard
        router.push('/dashboard');
      } catch (error) {
        console.error('OAuth callback failed:', error);
        router.push('/login?error=auth_failed');
      }
    }

    handleCallback();
  }, []);

  return <div>Completing login...</div>;
}
```

---

## ğŸ”„ Migration Strategy

### Parallel Running (2 weeks)

**Week 1-2**: Run both old and new auth systems
- Keep existing cookie-based auth
- Deploy new JWT auth endpoints
- New logins use new system
- Existing sessions continue with old system
- Monitor error rates and logs

### Gradual Migration

**Option A: Lazy Migration** (Recommended)
- Don't migrate existing sessions
- Users naturally re-login over 30 days
- Old system auto-expires
- Zero disruption to users

**Option B: Force Migration**
- Create migration endpoint
- Read old cookies
- Issue new token pair
- Run on middleware for all users
- Complete migration in 1-2 days

### Feature Flags

```typescript
// src/app/util/constants/index.ts
export const USE_NEW_AUTH = process.env.NEXT_PUBLIC_USE_NEW_AUTH === 'true';

// In middleware
if (USE_NEW_AUTH) {
  // New JWT auth
} else {
  // Old cookie auth
}
```

---

## ğŸ§ª Testing Plan

### Unit Tests

**JWT Utilities**:
- âœ… Sign and verify tokens
- âœ… Decode without verification
- âœ… Handle expired tokens
- âœ… Handle invalid signatures

**Token Service**:
- âœ… Issue token pairs
- âœ… Rotate tokens
- âœ… Detect token reuse
- âœ… Revoke tokens
- âœ… Enforce session limits

### Integration Tests

**OAuth Flow**:
- âœ… Complete Battle.net OAuth
- âœ… Complete Discord OAuth
- âœ… Receive access + refresh tokens
- âœ… Access protected route

**Token Refresh**:
- âœ… Refresh with valid token
- âœ… Fail with expired token
- âœ… Fail with revoked token
- âœ… Detect reuse and revoke family

**Session Management**:
- âœ… List active sessions
- âœ… Revoke single session
- âœ… Revoke all sessions
- âœ… Enforce 5 session limit

### Security Tests

**Attack Scenarios**:
- âœ… Token reuse attack (breach detection)
- âœ… XSS attempt (access token not in localStorage)
- âœ… CSRF attempt (SameSite cookies)
- âœ… Token theft (rotation limits damage)
- âœ… Brute force (rate limiting)

### Load Tests

**Concurrent Sessions**:
- âœ… 1000 concurrent users
- âœ… 100 refreshes/second
- âœ… Database query performance
- âœ… Token signing/verification performance

---

## ğŸ”™ Rollback Plan

### Immediate Rollback (< 1 hour)

**If critical issue detected**:
1. Set feature flag `USE_NEW_AUTH=false`
2. Deploy config change
3. New requests use old auth
4. Existing JWT sessions continue until expiry (15 min)

### Data Cleanup

**After rollback**:
- Keep auth tables (don't delete data)
- Disable Edge Functions
- Monitor for errors
- Investigate issue
- Fix and redeploy

### Progressive Rollout

**Rollout Strategy**:
- 5% of users (via feature flag randomization)
- Monitor for 24 hours
- 25% of users
- Monitor for 48 hours
- 100% of users

---

## ğŸ“Š Success Metrics

### Performance
- âœ… Token refresh < 100ms (p95)
- âœ… OAuth callback < 500ms (p95)
- âœ… Middleware validation < 10ms (p95)

### Security
- âœ… Zero XSS vulnerabilities
- âœ… Breach detection working (test with intentional reuse)
- âœ… Rate limiting effective (< 0.1% false positives)

### User Experience
- âœ… No unexpected logouts
- âœ… Seamless token refresh (users don't notice)
- âœ… Device management UI functional

### Reliability
- âœ… 99.9% uptime for auth endpoints
- âœ… < 0.1% error rate
- âœ… Automated token cleanup working

---

## ğŸ” Security Considerations

### Secrets Management
- **JWT Access Token Secret**: `process.env.JWT_ACCESS_SECRET` (256-bit)
- **JWT Refresh Token Secret**: `process.env.JWT_REFRESH_SECRET` (256-bit)
- Use different secrets for access and refresh tokens
- Rotate secrets every 90 days
- Store in Supabase secrets (not in code)

### Cookie Security
```typescript
{
  httpOnly: true,      // Prevent JS access
  secure: true,        // HTTPS only
  sameSite: 'strict',  // CSRF protection
  path: '/api/v1/auth',  // Limit scope
  maxAge: 30 * 24 * 60 * 60  // 30 days
}
```

### Token Expiry Strategy
- **Access Token**: 15 minutes (short window for attacks)
- **Refresh Token**: 30 days (balance security/UX)
- **Sliding Window**: Each refresh extends by 30 days

### Rate Limiting
- Prevent brute force attacks
- Protect against DoS
- Per-IP and per-user limits

---

## ğŸ“š Additional Resources

### JWT Best Practices
- https://datatracker.ietf.org/doc/html/rfc8725
- https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation

### Token Security
- https://owasp.org/www-community/vulnerabilities/Broken_Authentication
- https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html

### Supabase Edge Functions
- https://supabase.com/docs/guides/functions
- https://supabase.com/docs/guides/functions/deploy

---

## ğŸ¯ Next Steps

1. **Review this plan** - Ensure it aligns with your goals
2. **Set up development environment** - Supabase project, secrets
3. **Phase 1: Database setup** - Create tables and functions
4. **Phase 2: JWT utilities** - Build token generation/validation
5. **Phase 3: Edge Functions** - Deploy refresh/revoke endpoints
6. **Phase 4: OAuth updates** - Modify callbacks to issue tokens
7. **Phase 5-9**: Continue with remaining phases

**Estimated Total Time**: 23-32 hours of focused development

Let's build the most secure authentication system! ğŸš€
