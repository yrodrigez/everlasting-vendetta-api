# Authentication Migration Plan
## Enterprise-Grade JWT Token System with Refresh Token Rotation

**Goal**: Migrate from cookie-based authentication to a modern JWT token system with access tokens in memory, refresh tokens in HTTP-only cookies, automatic rotation, and breach detection.

**Learning Focus**: Token security, JWT internals, rotation strategies, breach detection, and Supabase Edge Functions.

---

## 📋 Table of Contents
1. [Current State](#current-state)
2. [Target Architecture](#target-architecture)
3. [Security Features](#security-features)
4. [Database Schema](#database-schema)
5. [Implementation Phases](#implementation-phases)
6. [API Endpoints](#api-endpoints)
7. [Client-Side Implementation](#client-side-implementation)
8. [Migration Strategy](#migration-strategy)
9. [Testing Plan](#testing-plan)
10. [Rollback Plan](#rollback-plan)

---

## 🔍 Current State

### Authentication Flow (Cookie-Based)

**Your existing implementation**:

```
┌─────────────────────────────────────────────────────────────────┐
│              1. OAuth Login (Battle.net/Discord)                 │
└─────────────────────────────────────────────────────────────────┘

User clicks "Login with Battle.net"
  ↓
/api/v1/oauth/bnet/auth → Redirect to Battle.net OAuth
  ↓
User authorizes on Battle.net
  ↓
/api/v1/oauth/bnet/callback (receives authorization code)
  ↓
Exchange code for Battle.net access token
  ↓
Store in cookie: bnetToken (expires ~1 hour, accessible to JS)


┌─────────────────────────────────────────────────────────────────┐
│          2. Session Installation (Character Selection)           │
└─────────────────────────────────────────────────────────────────┘

User selects character (frontend)
  ↓
SessionManager.initializeSession() checks:
  - Has evToken cookie? → Validate it's for selected character
  - No evToken but has bnetToken? → Call /api/v1/supabase/auth
  ↓
POST /api/v1/supabase/auth
  Body: {bnetToken, selectedCharacter}
  ↓
Backend calls Supabase Edge Function: ev_token_generate
  1. Validate bnetToken with Battle.net API
  2. Fetch user's WoW profile/characters
  3. Create/update user in Supabase (public.users, ev_member)
  4. Generate custom JWT token (evToken, 23 hours expiry)
  ↓
Return evToken → Store in cookie (accessible to JS)
  ↓
Frontend creates Supabase client with evToken
  ↓
User can make authenticated API calls


┌─────────────────────────────────────────────────────────────────┐
│         3. Automatic Token Refresh (Current Behavior)            │
└─────────────────────────────────────────────────────────────────┘

On page load/character change:
  ↓
Check if evToken exists and matches selected character
  ├─ YES: Use existing evToken (no API call)
  ├─ NO evToken but has bnetToken:
  │    → Regenerate evToken (call /api/v1/supabase/auth)
  └─ NO bnetToken:
       → Redirect to /api/v1/oauth/bnet/auth (re-login)
```

**Current Tokens**:
- **bnetToken** (cookie, ~1 hour): Battle.net OAuth access token, accessible to JS
- **discordToken** (cookie, ~7 days): Discord OAuth access token, accessible to JS
- **evToken** (cookie, 23 hours): Your app's custom JWT, generated by Supabase Edge Function `ev_token_generate`

**Current Files**:
- `/api/v1/oauth/bnet/callback/route.ts` - OAuth callback, stores bnetToken
- `/api/v1/supabase/auth/route.ts` - Session installer, generates evToken
- `SessionManager.ts` - Frontend session management, auto-refresh logic
- Supabase Edge Function: `ev_token_generate` - Token generation logic

### Issues with Current Approach
- ❌ **All tokens in cookies, accessible to JS** (`sameSite: 'lax'`, not `httpOnly`) → XSS vulnerable
- ❌ **No refresh token** - When bnetToken expires (~1 hour), user must re-login via OAuth
- ❌ **Character-specific tokens** - Switching characters regenerates evToken (unnecessary)
- ❌ **No session revocation** - Can't logout from other devices
- ❌ **No device tracking** - Can't see where you're logged in
- ❌ **No breach detection** - Stolen evToken is valid for 23 hours
- ❌ **OAuth tokens mixed with app tokens** - bnetToken stored alongside evToken (confusing)
- ❌ **23-hour session limit** - evToken expires, then needs bnetToken (which might also be expired)

---

## 🎯 Key Architecture Decisions

### Decision 1: User-Based Auth vs Character-Based Auth

**Problem**: Current system ties tokens to selected character. Switching characters = new token.

**Options Considered**:
- **Option A**: Keep character in access token payload (requires refresh on character switch)
- **Option B**: Decouple character from auth (character = UI state only)

**Decision**: **Option B - Decouple character from authentication** ✅

**Rationale**:
- Clean separation of concerns (auth = user identity, character = application state)
- No re-authentication when switching characters
- Standard pattern used by major WoW sites (WoWAudit, RaidHelper)
- Better UX (instant character switching)

**Implementation**:
```typescript
// Access token = User identity only
{
  sub: "user-uuid",
  email: "user@example.com",
  bnet_id: "123456",
  roles: ["member", "raider"]
  // NO character data in token
}

// Character selection = Client-side state (Zustand/Context)
const { selectedCharacter, setSelectedCharacter } = useCharacterStore();

// API queries pass both user_id and character_id
supabase
  .from('reservations')
  .select('*')
  .eq('user_id', user.id)
  .eq('character_id', selectedCharacter.id);
```

---

### Decision 2: Token Passing Method (OAuth Callback → Client)

**Problem**: How to securely pass access token from OAuth callback to client?

**Options Considered**:
- **Option A**: URL hash fragment (`/dashboard#access_token=...`)
- **Option B**: Authorization Code Flow with PKCE (refresh endpoint)
- **Option C**: Session cookie (HTTP-only, server-side only)

**Decision**: **Option B - OAuth 2.0 Authorization Code Flow** ✅

**Rationale**:
- **Most secure**: No tokens in URL (not in history, logs, or referrer headers)
- **Industry standard**: Used by Auth0, Supabase Auth, Clerk, NextAuth
- **XSS protection**: Refresh token in HTTP-only cookie, access token in memory
- **Works with Supabase direct access**: Client needs access token for Supabase client

**Flow**:
```
1. OAuth callback
   - Generate tokens via Supabase Edge Function
   - Store ONLY refreshToken in HTTP-only cookie
   - Redirect WITHOUT tokens in URL (clean redirect)

2. Client mounts (AuthContext)
   - Automatically calls /api/v1/auth/refresh
   - Receives accessToken in response
   - Stores in memory (useState)

3. User is authenticated
   - Access token auto-refreshes every 14 minutes (before expiry)
   - Refresh token rotates on each refresh
```

---

### Decision 3: Client-Side Architecture (Supabase Direct vs API Routes)

**Problem**: Need both Supabase direct access AND Next.js API routes.

**Solution**: **Hybrid Approach** ✅

**Implementation**:
```typescript
// AuthContext provides BOTH
const { supabase, accessToken } = useAuth();

// 1. Supabase Direct Access (preferred for DB queries)
const roster = await supabase
  .from('ev_member')
  .select('*');
// ✅ Fast (no API hop), works with RLS, realtime subscriptions

// 2. Axios for Next.js API Routes (optional)
import api from '@/app/lib/axios';
const data = await api.get('/services/roster');
// ✅ For complex server-side logic, external API proxies
```

**Rationale**:
- Keep existing Supabase direct access pattern (already used in components)
- Axios optional for API routes that need server-side processing
- No forced migration to API routes (gradual adoption)

---

### Decision 4: Token Storage Strategy

**Problem**: Where to store access tokens and refresh tokens?

**Decision**: **Industry Standard OAuth 2.0 Pattern** ✅

**Implementation**:
```
Access Token:
  - Storage: React state (memory only)
  - Lifetime: 15 minutes
  - Auto-refresh: 1 minute before expiry
  - Lost on page reload: YES (re-fetch via refresh endpoint)
  - XSS Protection: ✅ Not in localStorage or cookies

Refresh Token:
  - Storage: HTTP-only cookie
  - Lifetime: 30 days
  - Rotation: New token on every refresh
  - JavaScript Access: ❌ Cannot be read by JS
  - CSRF Protection: ✅ SameSite=strict

Battle.net OAuth Token (bnetToken):
  - Storage: ev_auth.oauth_providers table (database)
  - Returned: In /auth/refresh response if needed
  - Usage: Battle.net API calls only
  - Client Access: Available via useAuth() hook
```

---

### Decision 5: Error Handling Pattern

**Problem**: TypeScript doesn't enforce try/catch (no checked exceptions).

**Solution**: **Result Type Pattern** ✅

**Implementation**:
```typescript
// Result type for type-safe error handling
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

type AuthError =
  | { type: 'network'; message: string }
  | { type: 'unauthorized'; message: string }
  | { type: 'expired'; message: string };

// Functions return Result instead of throwing
const refreshToken = async (): Promise<Result<string, AuthError>> => {
  // ...
  if (!res.ok) {
    return { success: false, error: { type: 'unauthorized', message: 'Refresh failed' } };
  }
  return { success: true, data: accessToken };
};

// TypeScript forces error handling
const result = await refreshToken();
if (result.success) {
  console.log(result.data);  // TypeScript knows this is string
} else {
  console.error(result.error.type, result.error.message);
}
```

**Rationale**:
- Compiler-enforced error handling
- Better than neverthrow (no external dependency)
- Self-documenting error types

---

### Decision 6: Character Selection Flow

**Current Flow** (Character-First):
```
1. OAuth → bnetToken cookie
2. User selects character
3. Call ev_token_generate(bnetToken, character)
4. Get character-specific token
```

**New Flow** (User-First): ✅
```
1. OAuth → User-based JWT tokens (no character data)
2. Fetch all user's characters from Battle.net API
3. Store characters in database (ev_member)
4. Client-side character selection (no re-auth)
5. Selected character stored in Zustand/localStorage
6. API queries use: user.id + selectedCharacter.id
```

**Benefits**:
- Instant character switching (no API call)
- One authentication per user (not per character)
- Standard MMO site pattern

---

## 🏗️ Target Architecture

### New Authentication Flow
```
┌─────────────────────────────────────────────────────────────────┐
│                      1. OAuth Login Flow                         │
└─────────────────────────────────────────────────────────────────┘

User clicks "Login with Battle.net/Discord"
  ↓
Redirect to OAuth provider
  ↓
User authorizes
  ↓
OAuth callback receives authorization code
  ↓
Exchange code for provider tokens (in Supabase Edge Function)
  ↓
Create/Update user in Supabase auth.users
  ↓
Generate Token Pair:
  ┌─────────────────────────────────────────────────────────────┐
  │ Access Token (JWT)                                          │
  │ - Expires: 15 minutes                                       │
  │ - Stored: Client memory (React Context)                    │
  │ - Contains: user_id, roles, email, guild_rank, provider    │
  └─────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────┐
  │ Refresh Token (JWT)                                         │
  │ - Expires: 30 days                                          │
  │ - Stored: HTTP-only, Secure, SameSite cookie               │
  │ - Contains: user_id, jti (token ID), family_id, provider   │
  │ - Saved in database for revocation tracking                │
  └─────────────────────────────────────────────────────────────┘
  ↓
Response:
  {
    "accessToken": "eyJhbG...",
    "expiresIn": 900,
    "tokenType": "Bearer"
  }
  + Set-Cookie: refreshToken=...; HttpOnly; Secure; SameSite=Strict


┌─────────────────────────────────────────────────────────────────┐
│                   2. API Request Flow                            │
└─────────────────────────────────────────────────────────────────┘

Client makes API request
  ↓
Attach access token: Authorization: Bearer <accessToken>
  ↓
API validates JWT signature + expiry
  ↓
Extract user info from token payload
  ↓
Process request


┌─────────────────────────────────────────────────────────────────┐
│                  3. Token Refresh Flow                           │
└─────────────────────────────────────────────────────────────────┘

API returns 401 (access token expired)
  ↓
Client interceptor catches 401
  ↓
Call /api/v1/auth/refresh (refresh token sent via cookie)
  ↓
Supabase Edge Function validates refresh token:
  1. Verify JWT signature
  2. Check expiry
  3. Lookup token_jti in database
  4. Ensure not revoked
  5. Check token family is valid
  ↓
Token Rotation (Security Feature):
  - Generate NEW access token
  - Generate NEW refresh token (same family)
  - Invalidate OLD refresh token in database
  - Update last_used_at timestamp
  ↓
Return new access token + set new refresh token cookie
  ↓
Client retries original request with new access token


┌─────────────────────────────────────────────────────────────────┐
│              4. Breach Detection (Token Reuse)                   │
└─────────────────────────────────────────────────────────────────┘

Attacker steals old refresh token
  ↓
Attacker attempts to use already-rotated token
  ↓
System detects reuse (token exists but is already used/rotated)
  ↓
SECURITY BREACH DETECTED!
  ↓
Revoke ENTIRE token family (all tokens from that login session)
  ↓
Force user to re-login
  ↓
Log security event for audit
```

---

## 🔒 Security Features

### 1. Token Rotation
- **What**: Generate new refresh token on every refresh request
- **Why**: Limits exposure window if token is stolen
- **How**: Each refresh invalidates old token and issues new one

### 2. Token Families
- **What**: Group of tokens from same login session
- **Why**: Detect when stolen token is used after rotation
- **How**: All tokens share family_id; reuse detection revokes entire family

### 3. Sliding Window Sessions
- **What**: Users stay logged in as long as they're active
- **Why**: Better UX without compromising security
- **How**: Each refresh extends session by 30 days

### 4. Rate Limiting
- **Endpoints**:
  - `/auth/refresh`: 10 requests/minute per IP
  - `/oauth/*/callback`: 5 requests/minute per IP
  - `/auth/revoke`: 20 requests/minute per user
- **Implementation**: Upstash Redis or Supabase rate limiting

### 5. Device Tracking
- **What**: Track IP, user agent, last used time per token
- **Why**: Users can see and revoke suspicious sessions
- **How**: Store device info in refresh_tokens table

### 6. Concurrent Session Limits
- **What**: Max 5 active sessions per user
- **Why**: Prevent account sharing / credential stuffing
- **How**: Auto-revoke oldest session when limit exceeded

### 7. Audit Logging
- **Events to Log**:
  - Login (success/failure)
  - Token refresh
  - Token revocation
  - Breach detection
  - Password changes (if implemented)
- **Storage**: Supabase audit_logs table

---

## 🗄️ Database Schema

### Current State Analysis

Your existing database has:
- **`public.users`** - Basic user info (id, name, avatar_url, user_name)
- **`public.ev_member`** - Guild member data linked to users (user_id → users.id, character JSON, wow_account_id)
- **Custom schema: `ev_auth`** - Your custom authentication schema (NEW)

### New Auth Architecture

We'll use your custom `ev_auth` schema for all authentication tables. The relationship will be:

```
public.users (your existing app data)
    ↓ (id)
ev_auth.oauth_providers (NEW - track Battle.net & Discord OAuth)
    ↓
ev_auth.refresh_tokens (NEW - JWT token management)
    ↓
ev_auth.token_families (NEW - breach detection)
    ↓
ev_auth.auth_audit_logs (NEW - security monitoring)
```

### Supabase Tables (PostgreSQL)

#### 0. Schema Creation
```sql
-- Create custom auth schema
CREATE SCHEMA IF NOT EXISTS ev_auth;

-- Grant permissions
GRANT USAGE ON SCHEMA ev_auth TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA ev_auth TO postgres, service_role;
GRANT SELECT ON ALL TABLES IN SCHEMA ev_auth TO anon, authenticated;
```

#### 1. public.users (Existing - Enhanced)

**Your current table** (enhanced with auth fields):
```sql
-- Existing table structure (keep as is)
CREATE TABLE IF NOT EXISTS public.users (
  id TEXT PRIMARY KEY,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_modified TIMESTAMPTZ,
  name TEXT,
  user_name TEXT
);

-- Add these columns for enhanced auth (safe - won't affect existing data)
ALTER TABLE public.users
  ADD COLUMN IF NOT EXISTS email TEXT,
  ADD COLUMN IF NOT EXISTS is_banned BOOLEAN DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS banned_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS banned_reason TEXT,
  ADD COLUMN IF NOT EXISTS last_login_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS last_login_ip INET;

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);
CREATE INDEX IF NOT EXISTS idx_users_banned ON public.users(is_banned) WHERE is_banned = TRUE;

-- RLS (if not already enabled)
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

CREATE POLICY IF NOT EXISTS "Users can read all users" ON public.users
  FOR SELECT USING (true);

CREATE POLICY IF NOT EXISTS "Users can update own profile" ON public.users
  FOR UPDATE USING (id = current_setting('request.jwt.claims', true)::json->>'sub');
```

**Note**: Your `ev_member` table already tracks guild-specific data. The `users` table remains the source of truth for user identity across both Battle.net and Discord logins.

#### 2. ev_auth.oauth_providers (NEW - Multi-Provider Tracking)

This table tracks which OAuth providers (Battle.net, Discord) a user has connected:

```sql
CREATE TABLE ev_auth.oauth_providers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- User relationship
  user_id TEXT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  provider TEXT NOT NULL CHECK (provider IN ('bnet', 'discord')),

  -- Provider-specific IDs
  provider_user_id TEXT NOT NULL,  -- Battle.net ID or Discord snowflake
  provider_username TEXT,           -- BattleTag (e.g., "Player#1234") or Discord username
  provider_email TEXT,              -- Email from OAuth provider

  -- OAuth tokens (encrypted, for API calls to provider)
  -- These are the Battle.net/Discord tokens, NOT our JWT tokens
  access_token TEXT,               -- Provider's access token
  refresh_token TEXT,              -- Provider's refresh token (if available)
  token_expires_at TIMESTAMPTZ,

  -- Metadata
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ,
  last_sync_at TIMESTAMPTZ,        -- Last time we synced data from provider

  -- Provider-specific data (JSON)
  metadata JSONB,                  -- Store WoW account IDs, Battle.net profile, Discord guilds, etc.

  -- Constraints: User can link each provider once
  UNIQUE(provider, provider_user_id),  -- One Battle.net/Discord account globally
  UNIQUE(user_id, provider)            -- User can link each provider once
);

CREATE INDEX idx_oauth_providers_user ON ev_auth.oauth_providers(user_id);
CREATE INDEX idx_oauth_providers_provider ON ev_auth.oauth_providers(provider, provider_user_id);

-- RLS
ALTER TABLE ev_auth.oauth_providers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own providers" ON ev_auth.oauth_providers
  FOR SELECT USING (user_id = current_setting('request.jwt.claims', true)::json->>'sub');

CREATE POLICY "Service role full access" ON ev_auth.oauth_providers
  FOR ALL USING (auth.role() = 'service_role');
```

**Example Data**:
```sql
-- User "John" has both Battle.net and Discord linked
INSERT INTO ev_auth.oauth_providers VALUES
  ('uuid1', 'user123', 'bnet', '987654321', 'John#1234', 'john@bnet.com', 'bnet_token', NULL, NOW() + INTERVAL '1 hour', NOW(), NULL, NULL, '{"wow_accounts": [123, 456]}'),
  ('uuid2', 'user123', 'discord', '123456789', 'John#5678', 'john@discord.com', 'discord_token', NULL, NOW() + INTERVAL '7 days', NOW(), NULL, NULL, '{"guilds": ["789"]}');
```

#### 3. ev_auth.refresh_tokens (NEW - JWT Session Management)

```sql
CREATE TABLE ev_auth.refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- User and authentication
  user_id TEXT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  token_jti TEXT UNIQUE NOT NULL,  -- JWT ID (unique identifier)
  family_id UUID NOT NULL REFERENCES ev_auth.token_families(id) ON DELETE CASCADE,
  provider TEXT NOT NULL CHECK (provider IN ('bnet', 'discord')),

  -- Token lifecycle
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  last_used_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_reason TEXT,  -- 'manual', 'breach_detected', 'session_limit', 'logout_all'

  -- Device tracking
  ip_address INET,
  user_agent TEXT,
  device_fingerprint TEXT,  -- Optional: client-generated device ID

  -- Metadata
  is_rotated BOOLEAN DEFAULT FALSE,  -- Track if token was rotated
  rotated_to_jti TEXT  -- Points to new token after rotation
);

-- Indexes for performance
CREATE INDEX idx_refresh_tokens_user_id ON ev_auth.refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_jti ON ev_auth.refresh_tokens(token_jti);
CREATE INDEX idx_refresh_tokens_family ON ev_auth.refresh_tokens(family_id);
CREATE INDEX idx_refresh_tokens_expires ON ev_auth.refresh_tokens(expires_at) WHERE revoked_at IS NULL;

-- RLS Policies
ALTER TABLE ev_auth.refresh_tokens ENABLE ROW LEVEL SECURITY;

-- Users can only read their own tokens (for device management)
CREATE POLICY "Users can read own tokens" ON ev_auth.refresh_tokens
  FOR SELECT USING (user_id = current_setting('request.jwt.claims', true)::json->>'sub');

-- Service role can manage all tokens
CREATE POLICY "Service role full access" ON ev_auth.refresh_tokens
  FOR ALL USING (auth.role() = 'service_role');
```

#### 4. ev_auth.token_families (NEW - Breach Detection)

```sql
CREATE TABLE ev_auth.token_families (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  provider TEXT NOT NULL CHECK (provider IN ('bnet', 'discord')),

  -- Lifecycle
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_used_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_reason TEXT,

  -- Security
  breach_detected_at TIMESTAMPTZ,  -- When reuse was detected
  original_ip_address INET,         -- IP of initial login

  -- Metadata
  device_count INTEGER DEFAULT 1    -- Track how many rotations occurred
);

CREATE INDEX idx_token_families_user ON ev_auth.token_families(user_id);
CREATE INDEX idx_token_families_active ON ev_auth.token_families(user_id, revoked_at) WHERE revoked_at IS NULL;

-- RLS
ALTER TABLE ev_auth.token_families ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own families" ON ev_auth.token_families
  FOR SELECT USING (user_id = current_setting('request.jwt.claims', true)::json->>'sub');

CREATE POLICY "Service role full access" ON ev_auth.token_families
  FOR ALL USING (auth.role() = 'service_role');
```

#### 5. ev_auth.auth_audit_logs (NEW - Security Monitoring)

```sql
CREATE TABLE ev_auth.auth_audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Event details
  event_type TEXT NOT NULL,  -- 'login', 'refresh', 'revoke', 'breach_detected', 'logout'
  user_id TEXT REFERENCES public.users(id) ON DELETE SET NULL,
  provider TEXT CHECK (provider IN ('bnet', 'discord')),

  -- Context
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ip_address INET,
  user_agent TEXT,

  -- Additional metadata
  metadata JSONB,  -- Flexible storage for event-specific data
  success BOOLEAN NOT NULL,
  error_message TEXT
);

CREATE INDEX idx_audit_logs_user ON ev_auth.auth_audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_event ON ev_auth.auth_audit_logs(event_type, created_at DESC);
CREATE INDEX idx_audit_logs_created ON ev_auth.auth_audit_logs(created_at DESC);

-- RLS
ALTER TABLE ev_auth.auth_audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own logs" ON ev_auth.auth_audit_logs
  FOR SELECT USING (user_id = current_setting('request.jwt.claims', true)::json->>'sub');

CREATE POLICY "Service role full access" ON ev_auth.auth_audit_logs
  FOR ALL USING (auth.role() = 'service_role');
```

---

### Database Schema Summary

```
ev_auth (custom schema)
├── oauth_providers        - Track Battle.net & Discord OAuth connections
├── refresh_tokens         - JWT refresh tokens with rotation
├── token_families         - Group tokens for breach detection
└── auth_audit_logs        - Security event logging

public (existing schema)
├── users                  - User identity (enhanced with auth fields)
└── ev_member             - Guild member data (unchanged)
```

**Key Relationships**:
```sql
-- User can have multiple OAuth providers
public.users (1) ──< (N) ev_auth.oauth_providers

-- User can have multiple active sessions
public.users (1) ──< (N) ev_auth.refresh_tokens

-- Each login session creates a token family
public.users (1) ──< (N) ev_auth.token_families

-- Token family contains multiple rotated tokens
ev_auth.token_families (1) ──< (N) ev_auth.refresh_tokens
```

---

#### 6. Database Functions

**Cleanup Expired Tokens** (Run daily via pg_cron)
```sql
CREATE OR REPLACE FUNCTION ev_auth.cleanup_expired_tokens()
RETURNS void AS $$
BEGIN
  -- Delete expired tokens older than 7 days (keep for audit)
  DELETE FROM ev_auth.refresh_tokens
  WHERE expires_at < NOW() - INTERVAL '7 days';

  -- Delete orphaned token families
  DELETE FROM ev_auth.token_families
  WHERE id NOT IN (SELECT DISTINCT family_id FROM ev_auth.refresh_tokens)
    AND created_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**Revoke Token Family**
```sql
CREATE OR REPLACE FUNCTION ev_auth.revoke_token_family(
  p_family_id UUID,
  p_reason TEXT DEFAULT 'manual'
)
RETURNS void AS $$
BEGIN
  -- Revoke all tokens in family
  UPDATE ev_auth.refresh_tokens
  SET revoked_at = NOW(), revoked_reason = p_reason
  WHERE family_id = p_family_id AND revoked_at IS NULL;

  -- Mark family as revoked
  UPDATE ev_auth.token_families
  SET revoked_at = NOW(), revoked_reason = p_reason
  WHERE id = p_family_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**Enforce Session Limits**
```sql
CREATE OR REPLACE FUNCTION ev_auth.enforce_session_limit(
  p_user_id TEXT,
  p_max_sessions INTEGER DEFAULT 5
)
RETURNS void AS $$
BEGIN
  -- Revoke oldest sessions beyond limit
  WITH ranked_sessions AS (
    SELECT id,
           ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY last_used_at DESC NULLS LAST, created_at DESC) as rn
    FROM ev_auth.refresh_tokens
    WHERE user_id = p_user_id
      AND revoked_at IS NULL
      AND expires_at > NOW()
  )
  UPDATE ev_auth.refresh_tokens
  SET revoked_at = NOW(), revoked_reason = 'session_limit'
  WHERE id IN (
    SELECT id FROM ranked_sessions WHERE rn > p_max_sessions
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

## 📦 Implementation Phases

### Phase 1: Database & Infrastructure Setup ⏱️ 2-3 hours
- [ ] Create database migration files
- [ ] Run migrations on Supabase
- [ ] Set up pg_cron for token cleanup
- [ ] Create Supabase Edge Function project structure
- [ ] Configure environment variables (JWT secrets)

### Phase 2: JWT Utilities & Token Service ⏱️ 3-4 hours
- [ ] Create JWT utility module (sign, verify, decode)
- [ ] Create token service layer:
  - `issueTokenPair(userId, provider, deviceInfo)` → { accessToken, refreshToken }
  - `verifyAccessToken(token)` → decoded payload
  - `verifyRefreshToken(token)` → validated token data
  - `rotateRefreshToken(oldJti, userId, familyId)` → new token pair
  - `revokeToken(jti, reason)` → void
  - `revokeAllUserTokens(userId, reason)` → void
  - `detectTokenReuse(jti)` → boolean (breach detection)

### Phase 3: Supabase Edge Functions ⏱️ 4-5 hours
- [ ] **auth-refresh** function
  - Read refresh token from cookie
  - Validate + detect reuse
  - Rotate token
  - Return new access token
- [ ] **auth-revoke** function (logout single session)
- [ ] **auth-revoke-all** function (logout all devices)
- [ ] **auth-sessions** function (list active sessions)
- [ ] Deploy all Edge Functions

### Phase 4: OAuth Callback Updates ⏱️ 2-3 hours
- [ ] Update [/api/v1/oauth/bnet/callback/route.ts](src/app/api/v1/oauth/bnet/callback/route.ts)
  - Exchange code for Battle.net tokens
  - Create/update user in Supabase
  - Issue access + refresh token pair
  - Set refresh token in HTTP-only cookie
  - Return access token in response
- [ ] Update [/api/v1/oauth/discord/callback/route.ts](src/app/api/v1/oauth/discord/callback/route.ts)
  - Same flow as Battle.net

### Phase 5: Middleware Updates ⏱️ 1-2 hours
- [ ] Update [src/middleware.ts](src/middleware.ts)
  - Remove old cookie-based auth
  - Validate refresh token from cookie (for middleware-protected routes)
  - Check if token exists and not expired (lightweight check)
  - Let API routes handle full access token validation

### Phase 6: Client-Side Implementation ⏱️ 4-5 hours
- [ ] Create AuthContext provider
  - Store access token in memory
  - Provide login/logout/refresh functions
  - Auto-refresh before expiry (background timer)
- [ ] Create axios/fetch interceptor
  - Attach access token to requests
  - Handle 401 responses (call refresh endpoint)
  - Retry failed request with new token
  - Handle refresh failure (logout)
- [ ] Update [src/app/components/LoginButton.tsx](src/app/components/LoginButton.tsx)
  - Integrate with new OAuth flow
  - Store access token after callback
- [ ] Create SessionManager component (show active devices)

### Phase 7: Rate Limiting ⏱️ 2-3 hours
- [ ] Set up rate limiting (Upstash Redis or in-memory)
- [ ] Apply to auth endpoints
- [ ] Add rate limit headers to responses

### Phase 8: Testing & Validation ⏱️ 3-4 hours
- [ ] Unit tests for JWT utilities
- [ ] Integration tests for token flow
- [ ] Security tests (token reuse, breach detection)
- [ ] Load testing (concurrent sessions)
- [ ] Manual testing (device management, logout)

### Phase 9: Migration & Deployment ⏱️ 2-3 hours
- [ ] Deploy to staging environment
- [ ] Run parallel (old + new auth)
- [ ] Migrate existing users
- [ ] Monitor error rates
- [ ] Deploy to production
- [ ] Remove old auth code

**Total Estimated Time**: 23-32 hours

---

## 🔌 API Endpoints

### Supabase Edge Functions (Located in `supabase/functions/`)

#### 1. POST /api/v1/auth/refresh
**Purpose**: Exchange refresh token for new access token with rotation

**Request**:
```http
POST /api/v1/auth/refresh
Cookie: refreshToken=eyJhbG...
```

**Response** (Success):
```json
{
  "accessToken": "eyJhbG...",
  "expiresIn": 900,
  "tokenType": "Bearer"
}
```
Sets new `refreshToken` cookie

**Response** (Breach Detected):
```json
{
  "error": "token_reuse_detected",
  "message": "Security breach detected. All sessions have been revoked."
}
```
Status: 403

**Logic**:
```typescript
1. Read refresh token from cookie
2. Verify JWT signature
3. Query database for token_jti
4. Check if already rotated (is_rotated = true)
   → If YES: BREACH DETECTED
     - Revoke entire token family
     - Log security event
     - Return 403
5. Validate token not expired/revoked
6. Create new token pair (same family_id)
7. Mark old token as rotated (is_rotated = true, rotated_to_jti = new_jti)
8. Enforce session limits
9. Update last_used_at
10. Log audit event
11. Return new access token + set new refresh token cookie
```

#### 2. POST /api/v1/auth/revoke
**Purpose**: Revoke current session (logout from this device)

**Request**:
```http
POST /api/v1/auth/revoke
Cookie: refreshToken=eyJhbG...
Authorization: Bearer eyJhbG...
```

**Response**:
```json
{
  "success": true,
  "message": "Session revoked successfully"
}
```

**Logic**:
```typescript
1. Read refresh token from cookie
2. Decode to get jti
3. Revoke token in database (set revoked_at, revoked_reason='manual')
4. Clear refresh token cookie
5. Log audit event
```

#### 3. POST /api/v1/auth/revoke-all
**Purpose**: Revoke all user sessions (logout from all devices)

**Request**:
```http
POST /api/v1/auth/revoke-all
Authorization: Bearer eyJhbG...
```

**Response**:
```json
{
  "success": true,
  "message": "All sessions revoked successfully",
  "revokedCount": 5
}
```

**Logic**:
```typescript
1. Verify access token to get user_id
2. Revoke all token families for user
3. Log audit event
```

#### 4. GET /api/v1/auth/sessions
**Purpose**: List all active sessions for user

**Request**:
```http
GET /api/v1/auth/sessions
Authorization: Bearer eyJhbG...
```

**Response**:
```json
{
  "sessions": [
    {
      "id": "uuid",
      "provider": "bnet",
      "createdAt": "2025-10-01T12:00:00Z",
      "lastUsedAt": "2025-10-03T08:30:00Z",
      "expiresAt": "2025-10-31T12:00:00Z",
      "ipAddress": "192.168.1.1",
      "userAgent": "Mozilla/5.0...",
      "isCurrent": true
    }
  ]
}
```

**Logic**:
```typescript
1. Verify access token to get user_id
2. Query active refresh_tokens for user (not revoked, not expired)
3. Group by family_id (show one per login session)
4. Mark current session (compare jti)
5. Return session list
```

---

## 💻 Client-Side Implementation

### 1. AuthContext Provider (`src/app/context/AuthContext.tsx`)

```typescript
interface AuthContextType {
  accessToken: string | null;
  isAuthenticated: boolean;
  user: User | null;
  login: (provider: 'bnet' | 'discord') => void;
  logout: () => Promise<void>;
  logoutAll: () => Promise<void>;
  refreshToken: () => Promise<string>;
  getSessions: () => Promise<Session[]>;
  revokeSession: (sessionId: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }) {
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [user, setUser] = useState<User | null>(null);
  const refreshTimerRef = useRef<NodeJS.Timeout>();

  // Auto-refresh token before expiry
  useEffect(() => {
    if (!accessToken) return;

    const decoded = jwtDecode(accessToken);
    const expiresIn = decoded.exp * 1000 - Date.now();
    const refreshAt = expiresIn - 60000; // Refresh 1 min before expiry

    refreshTimerRef.current = setTimeout(() => {
      refreshToken();
    }, refreshAt);

    return () => clearTimeout(refreshTimerRef.current);
  }, [accessToken]);

  // Refresh on mount (page reload)
  useEffect(() => {
    refreshToken().catch(() => {
      // Refresh token expired or invalid
      setAccessToken(null);
      setUser(null);
    });
  }, []);

  const refreshToken = async () => {
    const res = await fetch('/api/v1/auth/refresh', {
      method: 'POST',
      credentials: 'include' // Send cookies
    });

    if (!res.ok) {
      throw new Error('Refresh failed');
    }

    const { accessToken } = await res.json();
    setAccessToken(accessToken);

    const decoded = jwtDecode(accessToken);
    setUser({
      id: decoded.sub,
      email: decoded.email,
      roles: decoded.roles,
      provider: decoded.provider
    });

    return accessToken;
  };

  const logout = async () => {
    await fetch('/api/v1/auth/revoke', {
      method: 'POST',
      credentials: 'include'
    });
    setAccessToken(null);
    setUser(null);
  };

  // ... other methods

  return (
    <AuthContext.Provider value={{
      accessToken,
      isAuthenticated: !!accessToken,
      user,
      login,
      logout,
      logoutAll,
      refreshToken,
      getSessions,
      revokeSession
    }}>
      {children}
    </AuthContext.Provider>
  );
}
```

### 2. Axios Interceptor (`src/app/lib/axios.ts`)

```typescript
import axios from 'axios';
import { useAuth } from '@/app/context/AuthContext';

const api = axios.create({
  baseURL: '/api/v1',
  withCredentials: true
});

// Request interceptor: attach access token
api.interceptors.request.use((config) => {
  const { accessToken } = useAuth();

  if (accessToken) {
    config.headers.Authorization = `Bearer ${accessToken}`;
  }

  return config;
});

// Response interceptor: handle 401 (expired token)
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // If 401 and not already retried
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const { refreshToken } = useAuth();
        const newAccessToken = await refreshToken();

        // Retry original request with new token
        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
        return api(originalRequest);
      } catch (refreshError) {
        // Refresh failed, redirect to login
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default api;
```

### 3. OAuth Callback Handler (Client-Side)

```typescript
// src/app/oauth-callback/page.tsx
'use client';

import { useEffect } from 'react';
import { useAuth } from '@/app/context/AuthContext';
import { useRouter } from 'next/navigation';

export default function OAuthCallbackPage() {
  const { refreshToken } = useAuth();
  const router = useRouter();

  useEffect(() => {
    async function handleCallback() {
      try {
        // Server-side callback already set refresh token cookie
        // Now just fetch the access token
        await refreshToken();

        // Redirect to dashboard
        router.push('/dashboard');
      } catch (error) {
        console.error('OAuth callback failed:', error);
        router.push('/login?error=auth_failed');
      }
    }

    handleCallback();
  }, []);

  return <div>Completing login...</div>;
}
```

---

## 🔄 Migration Strategy

### Parallel Running (2 weeks)

**Week 1-2**: Run both old and new auth systems
- Keep existing cookie-based auth
- Deploy new JWT auth endpoints
- New logins use new system
- Existing sessions continue with old system
- Monitor error rates and logs

### Gradual Migration

**Option A: Lazy Migration** (Recommended)
- Don't migrate existing sessions
- Users naturally re-login over 30 days
- Old system auto-expires
- Zero disruption to users

**Option B: Force Migration**
- Create migration endpoint
- Read old cookies
- Issue new token pair
- Run on middleware for all users
- Complete migration in 1-2 days

### Feature Flags

```typescript
// src/app/util/constants/index.ts
export const USE_NEW_AUTH = process.env.NEXT_PUBLIC_USE_NEW_AUTH === 'true';

// In middleware
if (USE_NEW_AUTH) {
  // New JWT auth
} else {
  // Old cookie auth
}
```

---

## 🧪 Testing Plan

### Unit Tests

**JWT Utilities**:
- ✅ Sign and verify tokens
- ✅ Decode without verification
- ✅ Handle expired tokens
- ✅ Handle invalid signatures

**Token Service**:
- ✅ Issue token pairs
- ✅ Rotate tokens
- ✅ Detect token reuse
- ✅ Revoke tokens
- ✅ Enforce session limits

### Integration Tests

**OAuth Flow**:
- ✅ Complete Battle.net OAuth
- ✅ Complete Discord OAuth
- ✅ Receive access + refresh tokens
- ✅ Access protected route

**Token Refresh**:
- ✅ Refresh with valid token
- ✅ Fail with expired token
- ✅ Fail with revoked token
- ✅ Detect reuse and revoke family

**Session Management**:
- ✅ List active sessions
- ✅ Revoke single session
- ✅ Revoke all sessions
- ✅ Enforce 5 session limit

### Security Tests

**Attack Scenarios**:
- ✅ Token reuse attack (breach detection)
- ✅ XSS attempt (access token not in localStorage)
- ✅ CSRF attempt (SameSite cookies)
- ✅ Token theft (rotation limits damage)
- ✅ Brute force (rate limiting)

### Load Tests

**Concurrent Sessions**:
- ✅ 1000 concurrent users
- ✅ 100 refreshes/second
- ✅ Database query performance
- ✅ Token signing/verification performance

---

## 🔙 Rollback Plan

### Immediate Rollback (< 1 hour)

**If critical issue detected**:
1. Set feature flag `USE_NEW_AUTH=false`
2. Deploy config change
3. New requests use old auth
4. Existing JWT sessions continue until expiry (15 min)

### Data Cleanup

**After rollback**:
- Keep auth tables (don't delete data)
- Disable Edge Functions
- Monitor for errors
- Investigate issue
- Fix and redeploy

### Progressive Rollout

**Rollout Strategy**:
- 5% of users (via feature flag randomization)
- Monitor for 24 hours
- 25% of users
- Monitor for 48 hours
- 100% of users

---

## 📊 Success Metrics

### Performance
- ✅ Token refresh < 100ms (p95)
- ✅ OAuth callback < 500ms (p95)
- ✅ Middleware validation < 10ms (p95)

### Security
- ✅ Zero XSS vulnerabilities
- ✅ Breach detection working (test with intentional reuse)
- ✅ Rate limiting effective (< 0.1% false positives)

### User Experience
- ✅ No unexpected logouts
- ✅ Seamless token refresh (users don't notice)
- ✅ Device management UI functional

### Reliability
- ✅ 99.9% uptime for auth endpoints
- ✅ < 0.1% error rate
- ✅ Automated token cleanup working

---

## 🔐 Security Considerations

### Secrets Management
- **JWT Access Token Secret**: `process.env.JWT_ACCESS_SECRET` (256-bit)
- **JWT Refresh Token Secret**: `process.env.JWT_REFRESH_SECRET` (256-bit)
- Use different secrets for access and refresh tokens
- Rotate secrets every 90 days
- Store in Supabase secrets (not in code)

### Cookie Security
```typescript
{
  httpOnly: true,      // Prevent JS access
  secure: true,        // HTTPS only
  sameSite: 'strict',  // CSRF protection
  path: '/api/v1/auth',  // Limit scope
  maxAge: 30 * 24 * 60 * 60  // 30 days
}
```

### Token Expiry Strategy
- **Access Token**: 15 minutes (short window for attacks)
- **Refresh Token**: 30 days (balance security/UX)
- **Sliding Window**: Each refresh extends by 30 days

### Rate Limiting
- Prevent brute force attacks
- Protect against DoS
- Per-IP and per-user limits

---

## 📚 Additional Resources

### JWT Best Practices
- https://datatracker.ietf.org/doc/html/rfc8725
- https://auth0.com/docs/secure/tokens/refresh-tokens/refresh-token-rotation

### Token Security
- https://owasp.org/www-community/vulnerabilities/Broken_Authentication
- https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html

### Supabase Edge Functions
- https://supabase.com/docs/guides/functions
- https://supabase.com/docs/guides/functions/deploy

---

## 🎯 Next Steps

1. **Review this plan** - Ensure it aligns with your goals
2. **Set up development environment** - Supabase project, secrets
3. **Phase 1: Database setup** - Create tables and functions
4. **Phase 2: JWT utilities** - Build token generation/validation
5. **Phase 3: Edge Functions** - Deploy refresh/revoke endpoints
6. **Phase 4: OAuth updates** - Modify callbacks to issue tokens
7. **Phase 5-9**: Continue with remaining phases

**Estimated Total Time**: 23-32 hours of focused development

Let's build the most secure authentication system! 🚀
